<!--
This file is generated by a tool. Do not edit directly.
For open-source contributions the docs will be updated automatically.
-->

*Last updated: 2021-03-10.*

<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf_quant_finance.models.hjm.swaption_price" />
<meta itemprop="path" content="Stable" />
</div>

# tf_quant_finance.models.hjm.swaption_price

<!-- Insert buttons and diff -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<a target="_blank" href="https://github.com/google/tf-quant-finance/blob/master/tf_quant_finance/models/hjm/swaption_pricing.py">View source</a>



Calculates the price of European swaptions using the HJM model.

```python
tf_quant_finance.models.hjm.swaption_price(
    *, expiries, fixed_leg_payment_times, fixed_leg_daycount_fractions,
    fixed_leg_coupon, reference_rate_fn, num_hjm_factors, mean_reversion,
    volatility, time_step, corr_matrix=None, notional=None, is_payer_swaption=None,
    num_samples=1, random_type=None, seed=None, skip=0, dtype=None, name=None
)
```



<!-- Placeholder for "Used in" -->

A European Swaption is a contract that gives the holder an option to enter a
swap contract at a future date at a prespecified fixed rate. A swaption that
grants the holder the right to pay fixed rate and receive floating rate is
called a payer swaption while the swaption that grants the holder the right to
receive fixed and pay floating payments is called the receiver swaption.
Typically the start date (or the inception date) of the swap coincides with
the expiry of the swaption. Mid-curve swaptions are currently not supported
(b/160061740).

This implementation uses the HJM model to numerically value the swaption via
Monte-Carlo. For more information on the formulation of the HJM model, see
quasi_gaussian_hjm.py.


#### References:
  [1]: D. Brigo, F. Mercurio. Interest Rate Models-Theory and Practice.
  Second Edition. 2007. Section 6.7, page 237.

#### Args:


* <b>`expiries`</b>: A real `Tensor` of any shape and dtype. The time to expiration of
  the swaptions. The shape of this input determines the number (and shape)
  of swaptions to be priced and the shape of the output.
* <b>`fixed_leg_payment_times`</b>: A real `Tensor` of the same dtype as `expiries`.
  The payment times for each payment in the fixed leg. The shape of this
  input should be `expiries.shape + [n]` where `n` denotes the number of
  fixed payments in each leg. The `fixed_leg_payment_times` should be
  greater-than or equal-to the corresponding expiries.
* <b>`fixed_leg_daycount_fractions`</b>: A real `Tensor` of the same dtype and
  compatible shape as `fixed_leg_payment_times`. The daycount fractions for
  each payment in the fixed leg.
* <b>`fixed_leg_coupon`</b>: A real `Tensor` of the same dtype and compatible shape as
  `fixed_leg_payment_times`. The fixed rate for each payment in the fixed
  leg.
* <b>`reference_rate_fn`</b>: A Python callable that accepts expiry time as a real
  `Tensor` and returns a `Tensor` of shape `input_shape +
  [num_hjm_factors]`. Returns the continuously compounded zero rate at the
  present time for the input expiry time.
* <b>`num_hjm_factors`</b>: A Python scalar which corresponds to the number of factors
  in the HJM model to be used for pricing.
* <b>`mean_reversion`</b>: A real positive `Tensor` of shape `[num_hjm_factors]`.
  Corresponds to the mean reversion rate of each factor.
* <b>`volatility`</b>: A real positive `Tensor` of the same `dtype` and shape as
  `mean_reversion` or a callable with the following properties: (a)  The
    callable should accept a scalar `Tensor` `t` and a 1-D `Tensor` `r(t)`
    of shape `[num_samples]` and returns a 2-D `Tensor` of shape
    `[num_samples, num_hjm_factors]`. The variable `t`  stands for time and
    `r(t)` is the short rate at time `t`.  The function returns the
    instantaneous volatility `sigma(t) = sigma(t, r(r))`. When `volatility`
    is specified as a real `Tensor`, each factor is assumed to have a
    constant instantaneous volatility  and the  model is effectively a
    Gaussian HJM model. Corresponds to the instantaneous volatility of each
    factor.
* <b>`time_step`</b>: Scalar real `Tensor`. Maximal distance between time grid points
  in Euler scheme. Relevant when Euler scheme is used for simulation. This
  input is required.
* <b>`corr_matrix`</b>: A `Tensor` of shape `[num_hjm_factors, num_hjm_factors]` and
  the same `dtype` as `mean_reversion`. Specifies the correlation between
  HJM factors.
  Default value: `None` in which case the factors are assumed to be
    uncorrelated.
* <b>`notional`</b>: An optional `Tensor` of same dtype and compatible shape as
  `strikes`specifying the notional amount for the underlying swaps.
   Default value: None in which case the notional is set to 1.
* <b>`is_payer_swaption`</b>: A boolean `Tensor` of a shape compatible with `expiries`.
  Indicates whether the swaption is a payer (if True) or a receiver (if
  False) swaption. If not supplied, payer swaptions are assumed.
* <b>`num_samples`</b>: Positive scalar `int32` `Tensor`. The number of simulation
  paths during Monte-Carlo valuation. This input is ignored during analytic
  valuation.
  Default value: The default value is 1.
* <b>`random_type`</b>: Enum value of `RandomType`. The type of (quasi)-random number
  generator to use to generate the simulation paths. This input is relevant
  only for Monte-Carlo valuation and ignored during analytic valuation.
  Default value: `None` which maps to the standard pseudo-random numbers.
* <b>`seed`</b>: Seed for the random number generator. The seed is only relevant if
  `random_type` is one of `[STATELESS, PSEUDO, HALTON_RANDOMIZED,
  PSEUDO_ANTITHETIC, STATELESS_ANTITHETIC]`. For `PSEUDO`,
  `PSEUDO_ANTITHETIC` and `HALTON_RANDOMIZED` the seed should be an Python
  integer. For `STATELESS` and  `STATELESS_ANTITHETIC` must be supplied as
  an integer `Tensor` of shape `[2]`. This input is relevant only for
  Monte-Carlo valuation and ignored during analytic valuation.
  Default value: `None` which means no seed is set.
* <b>`skip`</b>: `int32` 0-d `Tensor`. The number of initial points of the Sobol or
  Halton sequence to skip. Used only when `random_type` is 'SOBOL',
  'HALTON', or 'HALTON_RANDOMIZED', otherwise ignored.
  Default value: `0`.
* <b>`dtype`</b>: The default dtype to use when converting values to `Tensor`s.
  Default value: `None` which means that default dtypes inferred by
    TensorFlow are used.
* <b>`name`</b>: Python string. The name to give to the ops created by this function.
  Default value: `None` which maps to the default name `hjm_swaption_price`.


#### Returns:

A `Tensor` of real dtype and shape expiries.shape + [num_hjm_factors]
containing the computed swaption prices. For swaptions that have reset in
the past (expiries<0), the function sets the corresponding option prices to
0.0.
